{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nimport { apiService, handleApiError } from '../utils/api';\nexport function useApi() {\n  _s();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Generic API call wrapper\n  const apiCall = useCallback(async (apiFunction, loadingState = true) => {\n    try {\n      if (loadingState) setIsLoading(true);\n      setError(null);\n      const result = await apiFunction();\n      return result;\n    } catch (err) {\n      const errorMessage = handleApiError(err);\n      setError(errorMessage);\n      console.error('API Error:', errorMessage);\n      return null;\n    } finally {\n      if (loadingState) setIsLoading(false);\n    }\n  }, []);\n\n  // File upload\n  const uploadFile = useCallback(async file => {\n    const result = await apiCall(async () => {\n      const response = await apiService.uploadFile(file);\n\n      // Convert response to UploadedFile format\n      const uploadedFile = {\n        file_id: response.file_id,\n        filename: file.name,\n        file_path: '',\n        // Will be set by backend\n        content_type: file.type,\n        size: file.size,\n        uploaded_at: Date.now()\n      };\n      return uploadedFile;\n    });\n    return result;\n  }, [apiCall]);\n\n  // Database connection\n  const connectDatabase = useCallback(async dbUrl => {\n    const result = await apiCall(async () => {\n      const response = await apiService.connectDatabase(dbUrl);\n      return response.status === 'success';\n    });\n    return result || false;\n  }, [apiCall]);\n\n  // Start ingestion\n  const startIngestion = useCallback(async () => {\n    const result = await apiCall(async () => {\n      const response = await apiService.startIngestion();\n\n      // Convert response to ProcessedChunk format\n      const chunks = [];\n      for (let i = 0; i < response.chunks_processed; i++) {\n        chunks.push({\n          chunk_id: `chunk_${Date.now()}_${i}`,\n          text: `Mock chunk ${i} from ingested data`,\n          metadata: {\n            source_file: 'ingested_data',\n            chunk_index: i,\n            chunk_type: 'ingested'\n          }\n        });\n      }\n      return chunks;\n    });\n    return result;\n  }, [apiCall]);\n\n  // Send chat message\n  const sendChatMessage = useCallback(async query => {\n    const result = await apiCall(async () => {\n      const response = await apiService.sendChatMessage(query);\n\n      // Convert response to ChatMessage format\n      const chatMessage = {\n        id: `msg_${Date.now()}`,\n        query: response.metadata.query,\n        answer: response.answer,\n        sources: response.sources,\n        timestamp: Date.now(),\n        metadata: response.metadata\n      };\n      return chatMessage;\n    });\n    return result;\n  }, [apiCall]);\n\n  // Get files\n  const getFiles = useCallback(async () => {\n    const result = await apiCall(async () => {\n      const response = await apiService.getFiles();\n      return response.files;\n    });\n    return result || [];\n  }, [apiCall]);\n\n  // Get chunks\n  const getChunks = useCallback(async () => {\n    const result = await apiCall(async () => {\n      const response = await apiService.getChunks();\n\n      // Convert response to ProcessedChunk format\n      const chunks = response.chunks.map((chunk, index) => ({\n        chunk_id: chunk.chunk_id || `chunk_${index}`,\n        text: chunk.text || 'No text available',\n        metadata: chunk.metadata || {\n          source_file: 'unknown',\n          chunk_index: index,\n          chunk_type: 'unknown'\n        }\n      }));\n      return chunks;\n    });\n    return result || [];\n  }, [apiCall]);\n\n  // Health check\n  const checkHealth = useCallback(async () => {\n    const result = await apiCall(async () => {\n      const response = await apiService.getHealth();\n      return response.status === 'healthy';\n    }, false);\n    return result || false;\n  }, [apiCall]);\n\n  // Clear error\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n  return {\n    isLoading,\n    error,\n    clearError,\n    uploadFile,\n    connectDatabase,\n    startIngestion,\n    sendChatMessage,\n    getFiles,\n    getChunks,\n    checkHealth\n  };\n}\n_s(useApi, \"IpnCi0NgL/1B2sSlQbjahhXgi0c=\");","map":{"version":3,"names":["useState","useCallback","apiService","handleApiError","useApi","_s","isLoading","setIsLoading","error","setError","apiCall","apiFunction","loadingState","result","err","errorMessage","console","uploadFile","file","response","uploadedFile","file_id","filename","name","file_path","content_type","type","size","uploaded_at","Date","now","connectDatabase","dbUrl","status","startIngestion","chunks","i","chunks_processed","push","chunk_id","text","metadata","source_file","chunk_index","chunk_type","sendChatMessage","query","chatMessage","id","answer","sources","timestamp","getFiles","files","getChunks","map","chunk","index","checkHealth","getHealth","clearError"],"sources":["E:/Nagendra/projects/PrivAI/privai-app/frontend/src/hooks/useApi.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\r\nimport { apiService, handleApiError } from '../utils/api';\r\nimport { UploadedFile, ProcessedChunk, ChatMessage } from '../types';\r\n\r\nexport function useApi() {\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // Generic API call wrapper\r\n  const apiCall = useCallback(async <T>(\r\n    apiFunction: () => Promise<T>,\r\n    loadingState: boolean = true\r\n  ): Promise<T | null> => {\r\n    try {\r\n      if (loadingState) setIsLoading(true);\r\n      setError(null);\r\n      \r\n      const result = await apiFunction();\r\n      return result;\r\n    } catch (err) {\r\n      const errorMessage = handleApiError(err);\r\n      setError(errorMessage);\r\n      console.error('API Error:', errorMessage);\r\n      return null;\r\n    } finally {\r\n      if (loadingState) setIsLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // File upload\r\n  const uploadFile = useCallback(async (file: File): Promise<UploadedFile | null> => {\r\n    const result = await apiCall(async () => {\r\n      const response = await apiService.uploadFile(file);\r\n      \r\n      // Convert response to UploadedFile format\r\n      const uploadedFile: UploadedFile = {\r\n        file_id: response.file_id,\r\n        filename: file.name,\r\n        file_path: '', // Will be set by backend\r\n        content_type: file.type,\r\n        size: file.size,\r\n        uploaded_at: Date.now()\r\n      };\r\n      \r\n      return uploadedFile;\r\n    });\r\n    \r\n    return result;\r\n  }, [apiCall]);\r\n\r\n  // Database connection\r\n  const connectDatabase = useCallback(async (dbUrl: string): Promise<boolean> => {\r\n    const result = await apiCall(async () => {\r\n      const response = await apiService.connectDatabase(dbUrl);\r\n      return response.status === 'success';\r\n    });\r\n    \r\n    return result || false;\r\n  }, [apiCall]);\r\n\r\n  // Start ingestion\r\n  const startIngestion = useCallback(async (): Promise<ProcessedChunk[] | null> => {\r\n    const result = await apiCall(async () => {\r\n      const response = await apiService.startIngestion();\r\n      \r\n      // Convert response to ProcessedChunk format\r\n      const chunks: ProcessedChunk[] = [];\r\n      for (let i = 0; i < response.chunks_processed; i++) {\r\n        chunks.push({\r\n          chunk_id: `chunk_${Date.now()}_${i}`,\r\n          text: `Mock chunk ${i} from ingested data`,\r\n          metadata: {\r\n            source_file: 'ingested_data',\r\n            chunk_index: i,\r\n            chunk_type: 'ingested'\r\n          }\r\n        });\r\n      }\r\n      \r\n      return chunks;\r\n    });\r\n    \r\n    return result;\r\n  }, [apiCall]);\r\n\r\n  // Send chat message\r\n  const sendChatMessage = useCallback(async (query: string): Promise<ChatMessage | null> => {\r\n    const result = await apiCall(async () => {\r\n      const response = await apiService.sendChatMessage(query);\r\n      \r\n      // Convert response to ChatMessage format\r\n      const chatMessage: ChatMessage = {\r\n        id: `msg_${Date.now()}`,\r\n        query: response.metadata.query,\r\n        answer: response.answer,\r\n        sources: response.sources,\r\n        timestamp: Date.now(),\r\n        metadata: response.metadata\r\n      };\r\n      \r\n      return chatMessage;\r\n    });\r\n    \r\n    return result;\r\n  }, [apiCall]);\r\n\r\n  // Get files\r\n  const getFiles = useCallback(async (): Promise<string[]> => {\r\n    const result = await apiCall(async () => {\r\n      const response = await apiService.getFiles();\r\n      return response.files;\r\n    });\r\n    \r\n    return result || [];\r\n  }, [apiCall]);\r\n\r\n  // Get chunks\r\n  const getChunks = useCallback(async (): Promise<ProcessedChunk[]> => {\r\n    const result = await apiCall(async () => {\r\n      const response = await apiService.getChunks();\r\n      \r\n      // Convert response to ProcessedChunk format\r\n      const chunks: ProcessedChunk[] = response.chunks.map((chunk: any, index: number) => ({\r\n        chunk_id: chunk.chunk_id || `chunk_${index}`,\r\n        text: chunk.text || 'No text available',\r\n        metadata: chunk.metadata || {\r\n          source_file: 'unknown',\r\n          chunk_index: index,\r\n          chunk_type: 'unknown'\r\n        }\r\n      }));\r\n      \r\n      return chunks;\r\n    });\r\n    \r\n    return result || [];\r\n  }, [apiCall]);\r\n\r\n  // Health check\r\n  const checkHealth = useCallback(async (): Promise<boolean> => {\r\n    const result = await apiCall(async () => {\r\n      const response = await apiService.getHealth();\r\n      return response.status === 'healthy';\r\n    }, false);\r\n    \r\n    return result || false;\r\n  }, [apiCall]);\r\n\r\n  // Clear error\r\n  const clearError = useCallback(() => {\r\n    setError(null);\r\n  }, []);\r\n\r\n  return {\r\n    isLoading,\r\n    error,\r\n    clearError,\r\n    uploadFile,\r\n    connectDatabase,\r\n    startIngestion,\r\n    sendChatMessage,\r\n    getFiles,\r\n    getChunks,\r\n    checkHealth\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}